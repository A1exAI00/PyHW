# -*- coding: utf-8 -*-
"""
Created on Sat Nov 13 21:07:53 2021

@author: Alex Akinin
Contains: 
    M_ro_const() - функция рассчёта массы шара заданного радиуса постоянной плотности 
    ro_const() - функция сравнения полёта по орбите с полётом в тоннеле для 
        шара постоянной плотности
    M_ro_linear() - функция рассчёта массы шара заданного радиуса и
        линейно изменяющейся плотности
    ro_linear() - функция сравнения полёта по орбите с полётом в тоннеле для 
        шара линейно изменяющейся плотности
    forOdeint_linear() - система ОДУ для ro_linear()
    M_ro_exp() - функция рассчёта массы шара заданного радиуса и
        экспоненциально изменяющейся плотности
    ro_exp() - функция сравнения полёта по орбите с полётом в тоннеле для 
        шара экспоненциально изменяющейся плотности
    forOdeint_exp() - система ОДУ для ro_exp()
"""


import numpy as np
# import sympy as sp
from scipy.integrate import odeint
import time


st = time.time()
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


def M_ro_const(ro, r_lim):
    '''
    Функция рассчёта массы шара заданного радиуса постоянной плотности
    Рассчитывается по заранее выведенной формуле для шара

    Parameters
    ----------
    ro : float / int
        Постоянная плотность.
    r_lim : float / int
        Верхний предел интегрирования.

    Returns
    -------
    mass : float
        Масса шара, ограниченного r_lim.

    '''
    # Готовая формула для массы
    mass = 8/3 * (pi**3) * ro * (r_lim**3)
    return mass


def ro_const():
    '''
    Функция сравнения полёта по орбите с полётом в тоннеле для 
        шара постоянной плотности
    Для облёта по орбите: из половина длины окружности и первой 
        космической скорости можно найти время 
    Для полёта в тоннеле: за основу берётся теорема Гаусса: 
        поверзность интегрирования - сфера
        радиус сферы - расстояние до центра шара

    Returns
    -------
    None.

    '''
    # Для полёта по орбите:
    # Плотность константа
    ro = 10
    M = M_ro_const(ro, r_max)

    # Готовая выведенная формула для времени облёта половины орбиты
    t1 = pi * r_max * np.sqrt(r_max/(G*M))

    # ----------

    # Для полёта в тоннеле
    # Выведенная формула для консервативного гармонического осциллятора
    w = np.sqrt(G * 8/3 * pi**3 * ro)
    T = 2*pi*(1/w)
    t2 = 0.5*T
    print(f'При ρ=const: \nпо орбите: {t1} \nв тонеле: {t2}')
    print()


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


def M_ro_linear(ro1, ro2, r_lim):
    '''
    Функция рассчёта массы шара заданного радиуса и 
        линейно изменяющейся плотности

    Parameters
    ----------
    ro1 : float / int
        Плотность в центре шара.
    ro2 : float / int
        Плотность на поверхности шара.
    r_lim : float / int
        Верхний предел интегрирования.

    Returns
    -------
    mass : float
        Масса шара, ограниченного r_lim.

    '''
    # Вычислить градиент плотности
    k = (ro2 - ro1)/r_lim

    # Найти первообразную
    def antideriv(x): return (k*x**4)/4 + (ro1*x**3)/3

    # Вычислить определенный интеграл
    def_integral = antideriv(r_lim) - antideriv(0)

    mass = 8 * pi**3 * def_integral
    return mass


def ro_linear():
    '''
    Функция сравнения полёта по орбите с полётом в тоннеле для 
        шара линейно изменяющейся плотности
    Для облёта по орбите: из половина длины окружности и первой 
        космической скорости можно найти время 
    Для полёта в тоннеле: за основу берётся теорема Гаусса: 
        поверзность интегрирования - сфера
        радиус сферы - расстояние до центра шара

    Returns
    -------
    None.

    '''
    global ro1_linear, ro2_linear, a
    ro1_linear, ro2_linear = 10, 1

    # Для полёта по орбите:
    M = M_ro_linear(ro1_linear, ro2_linear, r_max)

    # Готовая выведенная формула для времени облёта половины орбиты
    t1 = pi * r_max * np.sqrt(r_max/(G*M))

    # ----------

    # Для полёта в тонеле
    POINT_1, POINT_2, NUM_P = 0, 0.1, 1000
    t = np.linspace(POINT_1, POINT_2, NUM_P)
    init_param = (r_max, 0)

    # Решение дифф. уравнения падения тела в тоннель
    a = odeint(forOdeint_linear, init_param, t)

    # Найти точку экстремума
    t2 = 0
    for i in range(len(a[:, 0])):
        if i > 1 and i < NUM_P-2:
            if abs(a[:, 0][i+1]) > abs(a[:, 0][i]) and \
                    abs(a[:, 0][i+1]) > abs(a[:, 0][i+2]):
                t2 = t[i+1]
                break

    # Проверить, найден ли экстремум
    if t2 == 0:
        print('Для линейного закона выберите другие пределы')
    else:
        print(
            f'При ρ, изменяющемуся по линейному закону: \nпо орбите: {t1} \nв тонеле: {t2}')
    print()


def forOdeint_linear(y, t):
    '''Cистема ОДУ для ro_linear()'''
    y1, y2 = y
    return [y2, -G/(y1**2) * M_ro_linear(ro1_linear, ro2_linear, y1)]


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


def M_ro_exp(ro_zero, r_lim):
    '''
    Функция рассчёта массы шара заданного радиуса и
        экспоненциально изменяющейся плотности

    Parameters
    ----------
    ro_zero : float / int
         Ро нулевое.
    r_lim : float / int
        Верхний предел интегрирования.

    Returns
    -------
    mass : float
        Масса шара, ограниченного r_lim.

    '''
    r_lim = abs(r_lim)
    k = 10

    # Найти первообразную
    def ro_exp_antideriv(x): return -e**(-k*x) * \
        (2/(k**3) + (2*x)/(k**2) + (x**2)/k)

    # Вычислить определенный интеграл
    def_integral = ro_zero * (ro_exp_antideriv(r_lim) - ro_exp_antideriv(0))
    mass = 8 * pi**3 * def_integral
    return mass


def ro_exp():
    '''
    Функция сравнения полёта по орбите с полётом в тоннеле для 
        шара экспоненциально изменяющейся плотности
    Для облёта по орбите: из половина длины окружности и первой 
        космической скорости можно найти время 
    Для полёта в тоннеле: за основу берётся теорема Гаусса: 
        поверзность интегрирования - сфера
        радиус сферы - расстояние до центра шара

    Returns
    -------
    None.

    '''
    global ro_z, b
    ro_z = 100000

    # Для полёта по орбите:
    M = M_ro_exp(ro_z, r_max)

    # Готовая выведенная формула для времени облёта половины орбиты
    t1 = pi * r_max * np.sqrt(r_max/(G*M))

    # ----------

    # Для полёта в тонеле
    POINT_1, POINT_2, NUM_P = 0, 100, 1000
    t = np.linspace(POINT_1, POINT_2, NUM_P)
    init_param = (r_max, 0)

    # Решение дифф. уравнения падения тела в тонель
    b = odeint(forOdeint_exp, init_param, t)

    # Найти точку экстремума
    t2 = 0
    for i in range(len(b[:, 0])):
        if i > 1 and i < NUM_P-2:
            if abs(b[:, 0][i+1]) > abs(b[:, 0][i]) and \
                    abs(b[:, 0][i+1]) > abs(b[:, 0][i+2]):
                t2 = t[i+1]
                break

    # Проверить, найден ли экстремум
    if t2 == 0:
        print('Для эксп закона выберите другие пределы')
    else:
        print(
            f'При ρ, изменяющемуся по экспоненциальному закону: \nпо орбите: {t1} \nв тонеле: {t2}')
    print()


def forOdeint_exp(y, t):
    '''Cистема ОДУ для ro_exp()'''
    y1, y2 = y
    out = -G/(abs(y1)**3) * M_ro_exp(ro_z, y1) * y1
    return [y2, out]


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


G = 10
m = 50
r_max = 1000
pi = np.pi
e = np.e

print('Сравнение времён, необходимых для облета шара с первой космической скоростю и необхдимых для пролёта сквозь тонель через центр планеты')
print('!Все цифры абстрактные и не имеют отношения к реальным космическим телам!')
print()

ro_const()
ro_linear()
ro_exp()


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


print(f'Eval took: {time.time() - st} sec')
