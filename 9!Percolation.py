# -*- coding: utf-8 -*-
"""
Created on Fri Nov 12 21:23:48 2021

@author: Alex Akinin

–ó–∞–¥–∞—á–∞ –ø–µ—Ä–∫–æ–ª—è—Ü–∏–∏
–ü–†–û–ì–†–ê–ú–ú–ê ‚ùå–ù–ï –†–ê–ë–û–¢–ê–ï–¢‚ùå –ø–æ —Ç—Ä—ë–º –ø—Ä–∏—á–∏–Ω–∞–º:
    –º–æ–π –∞–ª–≥–æ—Ä–∏—Ç–º –ø–æ—á–µ–º—É-—Ç–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
    –∞–ª–≥–æ—Ä–∏—Ç–º Hoshen-Kopelman —Ç–æ–∂–µ üí©
    –ø—Ä–æ–≥—Ä–∞–º–º–∞ –¥–æ–ª–≥–æ –¥—É–º–∞–µ—Ç

–°—É—â–µ—Å—Ç–≤—É–µ—Ç –≤—Ç–æ—Ä–∞—è –≤–µ—Ä—Å–∏—è –∑–∞–¥–∞—á–∏ –ø–µ—Ä–∫–æ–ª—è—Ü–∏–∏  -  9!Percolation pygame.py


Contains: 
    class Cell - –∫–ª–∞—Å—Å, —Ö—Ä–∞–Ω—è—â–∏–π –≤ —Å–µ–±–µ –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–¥–Ω–æ–π –∫–ª–µ—Ç–∫–∏ 
    PathExists() - —Ñ—É–Ω–∫—Ü–∏—è, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∞—è, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å –º–µ–∂–¥—É 
        –¥–≤—É–º—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ –∫–ª–µ—Ç–∫–∞–º–∏
    checkHorisontalSides() - —Ñ—É–Ω–∫—Ü–∏—è, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∞—è, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å 
        –º–µ–∂–¥—É –ª–µ–≤–æ–π-–ø—Ä–∞–≤–æ–π –≥—Ä–∞–Ω—è–º–∏
    checkVerticalSides() - —Ñ—É–Ω–∫—Ü–∏—è, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∞—è, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å 
        –º–µ–∂–¥—É –Ω–∏–∂–Ω–µ–π-–≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω—è–º–∏
    checkSides() - –≤—ã–∑—ã–≤–∞–µ—Ç checkHorisontalSides() –∏ checkVerticalSides()
    mod_checkSides() - –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è, –µ—Å—Ç—å –ª–∏ –ø—É—Ç—å
    draw_prob_ro_dependency() - —Ñ—É–Ω–∫—Ü–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ 
        –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –ø—Ä–æ–±–æ—è –æ—Ç –≤–µ–ª–∏—á–∏–Ω—ã —Ä–æ
    drawGrid() - —Ñ—É–Ω–∫—Ü–∏—è, –æ—Ç—Ä–∏—Å–æ–≤—ã–≤–∞—é—â–∞—è —Å–µ—Ç–∫—É –∏–∑ –∫–ª–µ—Ç–æ–∫
"""


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


import numpy as np
import matplotlib.pyplot as plt
import time


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


class Cell:
    ''' –ö–ª–∞—Å—Å, —Ö—Ä–∞–Ω—è—â–∏–π –≤ —Å–µ–±–µ –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–¥–Ω–æ–π –∫–ª–µ—Ç–∫–∏ '''
    def __init__(self, pos, pass_val=None) -> None:
        '''
        –ú–µ—Ç–æ–¥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ (—Å–æ–∑–¥–∞–Ω–∏—è) –æ–±—ä–µ–∫—Ç–∞ –∫–ª–∞—Å—Å–∞ Cell

        Parameters
        ----------
        pos : 2D tuple
            –ü–æ–∑–∏—Ü–∏—è –∫–ª–µ—Ç–∫–∏.
        pass_val : int, optional
            –ó–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–Ω–æ –ø—Ä–∏–≤–æ–∏—Ç—å –∫–ª–µ—Ç–∫–µ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏. The default is None.
        '''
        self.x, self.y = pos
        if pass_val == None:
            self.val = 0 if np.random.rand() > ro else 1
        else:
            self.val = pass_val
        self.open = None
        self.marker = None

    def setOpen(self) -> None:
        '''
        –ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç –∫–ª–µ—Ç–∫–µ —Å—Ç–∞—Ç—É—Å –æ—Ç–∫—Ä—ã—Ç–æ–π, –µ—Å–ª–∏ –æ–Ω–∞ —É–∂–µ –Ω–µ –±—ã–ª–∞ 
            –∑–∞–∫—Ä—ã—Ç–∞ –∏–ª–∏ –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–ª–µ—Ç–∫–∏ —Ä–∞–≤–Ω–æ 0 (–∫–ª–µ—Ç–∫–∞ –Ω–µ–ø—Ä–æ–≤–æ–¥—è—â–∞—è)
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Ñ—É–Ω–∫—Ü–∏–∏ PathExists()
        '''

        if self.open != False and self.val != 0:
            self.open = True

    def setClosed(self) -> None:
        ''' Setter –∑–Ω–∞—á–µ–Ω–∏—è False –¥–ª—è self.open '''
        self.open = False

    def isOpen(self):
        '''
        –í—ã–∑–æ–≤ –∑–Ω–∞—á–µ–Ω–∏—è self.open - –æ—Ç–∫—Ä—ã—Ç–∞—è –ª–∏ –∏–ª–∏ –∑–∞–∫—Ä—ã—Ç–∞—è –∫–ª–µ—Ç–∫–∞

        Returns
        -------
        boolean
            True : –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç–∞
            False : –µ—Å–ª–∏ –∑–∞–∫—Ä—ã—Ç–∞.
        '''

        return True if self.open == True else False

    def openReset(self) -> None:
        ''' Reset –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞ –æ—Ç–∫—Ä—ã—Ç–æ—Å—Ç–∏ '''
        if self.open != None:
            self.open = None

    def setVal(self, pass_val) -> None:
        ''' Setter –¥–ª—è self.val '''
        self.val = pass_val

    def getVal(self):
        ''' Getter –¥–ª—è self.val '''
        return self.val

    def getMarker(self):
        ''' Setter –¥–ª—è self.marker '''
        return self.marker

    def setMarker(self, m) -> None:
        ''' Setter –¥–ª—è self.marker '''
        if self.val != 0:
            self.marker = m


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


def PathExists(gr, p1, p2, tmp_N=None):
    '''
    –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å –æ—Ç —Ä1 –¥–æ —Ä2 –ø–æ –ø—Ä–æ–≤–æ–¥—è—â–∏–º –∫–ª–µ—Ç–∫–∞–º
    –ê–ª–≥–æ—Ä–∏—Ç–º –∫—Ä–∞—Ç–∫–æ:
        1. –ù–∞—á–∞–ª—å–Ω–æ–π –∫–ª–µ—Ç–∫–µ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è —Å—Ç–∞—Ç—É—Å –æ—Ç–∫—Ä—ã—Ç–æ–π
        2. –¶–∏–∫–ª while:
            –ò–∑ –≤—Å–µ—Ö –∫–ª–µ—Ç–æ–∫ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è —Ç–∞, —É –∫–æ—Ç–æ—Ä–æ–π —Å—Ç–∞—Ç—É—Å –æ—Ç–∫—Ä—ã—Ç–æ–π
            –ï—Å–ª–∏ —ç—Ç–∞ –∫–ª–µ—Ç–∫–∞ —è–≤–ª—è–µ—Ç—Å—è –∫–æ–Ω–µ—á–Ω–æ–π, —Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è True
            –ï—Å–ª–∏ –±–æ–ª—å—à–µ –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∫–ª–µ—Ç–æ–∫, —Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è False
            –≠—Ç–æ–π –∫–ª–µ—Ç–∫–µ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è —Å—Ç–∞—Ä—É—Å –∑–∞–∫—Ä—ã—Ç–æ–π
            –°–æ—Å–µ–¥—è–º —ç—Ç–æ–π –∫–ª–µ—Ç–∫–∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è —Å—Ç–∞—Ç—É—Å –æ—Ç–∫—Ä—ã—Ç—ã—Ö


    Parameters
    ----------
    gr : 2D NxN array of Cells
        –ö–≤–∞–¥—Ä–∞—Ç–Ω—ã–π –º–∞—Å—Å–∏–≤ –∏–∑ –∫–ª–µ—Ç–æ–∫.
    p1 : 2D tuple
        –ü–æ–∑–∏—Ü–∏—è –Ω–∞—á–∞–ª—å–Ω–æ–π –∫–ª–µ—Ç–∫–∏.
    p2 : 2D tuple
        –ü–æ–∑–∏—Ü–∏—è –∫–æ–Ω–µ—á–Ω–æ–π –∫–ª–µ—Ç–∫–∏.
    tmp_N : int, optional
        –†–∞–∑–º–µ—Ä –º–∞—Å—Å–∏–≤–∞. The default is None.

    Returns
    -------
    bool
        True - —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—É—Ç—å
        False - –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—É—Ç—å.
    '''
    x1, y1 = p1
    x2, y2 = p2

    # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏—è —Ä1 –∏–ª–∏ —Ä2 —Ä–∞–≤–Ω—ã 0
    if gr[x1][y1].val == 0 or gr[x2][y2].val == 0:
        return False

    # –£–Ω–∞—Å–ª–µ–¥–æ–≤–∞—Ç—å N –∏–ª–∏ –≤–∑—è—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—É—é
    if tmp_N == None:
        tmp_N = N

    # –°–¥–µ–ª–∞—Ç—å –ü–û–õ–ù–£–Æ –∫–æ–ø–∏—é —Å–µ—Ç–∫–∏ –∏–∑ –∫–ª–µ—Ç–æ–∫
    # gr = copy.deepcopy(grid)

    # –û—Ç—á–∏—Å—Ç–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–º, –æ—Ç–∫—Ä—ã—Ç–∞ –∫–ª–µ—Ç–∫–∞ –∏–ª–∏ –Ω–µ—Ç
    # –≠—Ç–æ –∑–∞–º–µ–Ω–∞ –ø–æ–ª–Ω–æ–π –∫–æ–ø–∏–∏ –æ–±—ä–µ–∫—Ç–æ–≤ —Å–µ—Ç–∫–∏
    # –ü–æ–ª–Ω–∞—è –∫–æ–ø–∏—è –∑–∞–Ω–∏–º–∞–µ—Ç –æ—á–µ–Ω—å –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
    for i in range(tmp_N):
        for j in range(tmp_N):
            gr[x1][y1].openReset()

    # –ó–∞–¥–∞—Ç—å –Ω—ã–Ω–µ—à–Ω—é—é –∫–ª–µ—Ç–∫—É –∏ –¥–µ–ª–∞–µ–º –µ—ë –æ—Ç–∫—Ä—ã—Ç–æ–π
    curX, curY = p1
    gr[curX][curY].setOpen()

    loop = True
    while loop:

        # –ù–∞–π—Ç–∏ —Å–≤–æ–±–æ–¥–Ω—É—é –∫–ª–µ—Ç–∫—É –∏ —Å–¥–µ–ª–∞—Ç—å –µ—ë –Ω—ã–Ω–µ—à–Ω–µ–π
        Open_exist = False
        for i in range(tmp_N):
            for j in range(tmp_N):

                # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –µ—Å–ª–∏ –∫–ª–µ—Ç–∫–∞ —è–≤–ª—è–µ—Ç—Å—è –æ—Ç–∫—Ä—ã—Ç–æ–π
                if gr[i][j].isOpen():
                    Open_exist = True
                    curX, curY = i, j
                    break

            if Open_exist:
                break

        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –µ—Å–ª–∏ –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∫–ª–µ—Ç–æ–∫
        if not Open_exist:
            loop = False
            return False

        # –°–¥–µ–ª–∞—Ç—å –Ω—ã–Ω–µ—à–Ω—é—é –∫–ª–µ—Ç–∫—É –∏–∑ –∑–∞–∫—Ä—ã—Ç–æ–π
        gr[curX][curY].setClosed()

        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –µ—Å–ª–∏ –Ω—ã–Ω–µ—à–Ω—è—è –∫—Ä–µ—Ç–∫–∞ —è–≤–ª—è–µ—Ç—Å—è —Ü–µ–ª—å—é
        if (curX, curY) == p2:
            loop = False
            return True

        # –°–¥–µ–ª–∞—Ç—å —Å–æ—Å–µ–¥–Ω–∏–µ –∫–ª–µ—Ç–∫–∏ —Å–≤–æ–±–æ–¥–Ω—ã–º–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
        if curX > 0:
            gr[curX-1][curY].setOpen()
        if curX < tmp_N-1:
            gr[curX+1][curY].setOpen()
        if curY > 0:
            gr[curX][curY-1].setOpen()
        if curY < tmp_N-1:
            gr[curX][curY+1].setOpen()


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


def Hoshen_Kopelman(grid, tmp_N=None):

    # –ó–∞–¥–∞–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –º–∞—Å—Å–∏–≤–∞
    if tmp_N == None:
        tmp_N = N

    # –û—Ç—á–∏—Å—Ç–∫–∞ –º–∞—Ä–∫–µ—Ä–æ–≤
    for i in range(tmp_N):
        for j in range(tmp_N):
            grid[i][j].setMarker(None)

    highest_marker = 0

    # –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª –∞–ª–≥–æ—Ä–∏—Ç–º–∞
    for i in range(tmp_N):
        for j in range(tmp_N):
            neighbors = []

            # –°–±–æ—Ä –º–∞—Ä–∫–µ—Ä–æ–≤ —Å–æ—Å–µ–¥–µ–π
            # –ú–∞—Ä–∫–µ—Ä —Å–ª–µ–≤–∞
            if i > 0:
                l_neighbor = grid[i-1][j].getMarker()
                if l_neighbor != None:
                    neighbors.append(l_neighbor)

            # –ú–∞—Ä–∫–µ—Ä —Å–Ω–∏–∑—É
            if j > 0:
                d_neighbor = grid[i][j-1].getMarker()
                if d_neighbor != None:
                    neighbors.append(d_neighbor)

            # –ú–∞—Ä–∫–µ—Ä —Å–ø—Ä–∞–≤–∞
            if i < tmp_N-1:
                r_neighbor = grid[i+1][j].getMarker()
                if r_neighbor != None:
                    neighbors.append(r_neighbor)

            # –ú–∞—Ä–∫–µ—Ä —Å–≤–µ—Ä—Ö—É
            if j < tmp_N-1:
                u_neighbor = grid[i][j+1].getMarker()
                if u_neighbor != None:
                    neighbors.append(u_neighbor)

            # –ê–Ω–∞–ª–∏–∑ —Å–æ–±—Ä–∞–Ω—ã—Ö –º–∞—Ä–∫–µ—Ä–æ–≤
            if len(neighbors) == 1:
                grid[i][j].setMarker(neighbors[0])

            if len(neighbors) == 2:
                low_mark = sorted(neighbors)[0]
                other_mark = sorted(neighbors)[1]
                grid[i][j].setMarker(neighbors[0])
                for i in range(tmp_N):
                    for j in range(tmp_N):
                        if grid[i][j].getMarker() == other_mark:
                            grid[i][j].setMarker(low_mark)

            if len(neighbors) == 0:
                highest_marker += 1
                grid[i][j].setMarker(highest_marker)


""" 
def union(gr, set_mark, other_mark, tmp_N=None):
    if tmp_N == None:
        tmp_N = N
    
    for i in range(tmp_N):
        for j in range(tmp_N):
            if gr[i][j].getMarker() == other_mark:
                gr[i][j].setMarker(set_mark) 
 """


def checkHoshen_Kopelman(grid, tmp_N=None):

    # –ù–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –º–∞—Å—Å–∏–≤–∞
    if tmp_N == None:
        tmp_N = N

    Hoshen_Kopelman(grid, tmp_N)

    for i in range(tmp_N):
        for j in range(N):
            m_1 = grid[0][i].getMarker()
            m_2 = grid[tmp_N-1][j].getMarker()
            if m_1 != None and m_2 != None:
                if m_1 == m_2:
                    print(1, i, j, m_1, m_2)
                    return True

    for i in range(tmp_N):
        for j in range(N):
            m_1 = grid[i][0].getMarker()
            m_2 = grid[j][tmp_N-1].getMarker()
            if m_1 != None and m_2 != None:
                if m_1 == m_2:
                    print(2, i, j, m_1, m_2)
                    return True

    return False


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


def checkHorisontalSides(grid):
    '''
    –ü–æ –æ—á–µ—Ä–µ–¥–∏ —Å—Ç–∞–≤–∏—Ç –≤ –ø–∞—Ä—É –∫–∞–∂–¥–æ–π –∫–ª–µ—Ç–∫–µ —Å –ª–µ–≤–æ–π –≥—Ä–∞–Ω–∏ 
        –∫–ª–µ—Ç–∫—É —Å –ø—Ä–∞–≤–æ–π –≥—Ä–∞–Ω–∏ –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å –º–µ–∂–¥—É –Ω–∏–º–∏ 
    –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞–∑–∞–ª–∞ —Å–≤–æ—é –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∏–∑-–∑–∞ –æ—á–µ–Ω—å —á–∞—Å—Ç–æ–≥–æ –≤—ã–∑–æ–≤–∞ 
        —Ñ—É–Ω–∫—Ü–∏–∏ PathExists()

    Parameters
    ----------
    grid : 2D NxN array of Cells
        –ö–≤–∞–¥—Ä–∞—Ç–Ω—ã–π –º–∞—Å—Å–∏–≤ –∏–∑ –∫–ª–µ—Ç–æ–∫.

    Returns
    -------
    bool
        True - —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—É—Ç—å
        False - –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—É—Ç—å.
    '''
    for i in range(N):
        for j in range(N):
            if PathExists(grid, (i, 0), (j, N-1)):
                return True
    return False


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


def checkVerticalSides(grid):
    '''
    –ü–æ –æ—á–µ—Ä–µ–¥–∏ —Å—Ç–∞–≤–∏—Ç –≤ –ø–∞—Ä—É –∫–∞–∂–¥–æ–π –∫–ª–µ—Ç–∫–µ —Å –Ω–∏–∂–Ω–µ–π –≥—Ä–∞–Ω–∏ 
        –∫–ª–µ—Ç–∫—É —Å –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏ –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å –º–µ–∂–¥—É –Ω–∏–º–∏ 
    –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞–∑–∞–ª–∞ —Å–≤–æ—é –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∏–∑-–∑–∞ –æ—á–µ–Ω—å —á–∞—Å—Ç–æ–≥–æ –≤—ã–∑–æ–≤–∞ 
        —Ñ—É–Ω–∫—Ü–∏–∏ PathExists()

    Parameters
    ----------
    grid : 2D NxN array of Cells
        –ö–≤–∞–¥—Ä–∞—Ç–Ω—ã–π –º–∞—Å—Å–∏–≤ –∏–∑ –∫–ª–µ—Ç–æ–∫.

    Returns
    -------
    bool
        True - —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—É—Ç—å
        False - –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—É—Ç—å.
    '''
    for i in range(N):
        for j in range(N):
            if PathExists(grid, (0, i), (N-1, j)):
                return True
    return False


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


def checkSides(grid):
    '''
    –í—ã–∑—ã–≤–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏–∏ checkVerticalSides() –∏ checkHorisontalSides()
    –ï—Å–ª–∏ —Ö–æ—Ç—å –æ–¥–Ω–∞ –∏–∑ –Ω–∏—Ö –≤–æ–∑–≤—Ä–≤—â–∞–µ—Ç True, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç True
    –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞–∑–∞–ª–∞ —Å–≤–æ—é –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∏–∑-–∑–∞ –≤—ã–∑–æ–≤–∞ –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã—Ö 
        checkVerticalSides() –∏ checkHorisontalSides()

    Parameters
    ----------
    grid : 2D NxN array of Cells
        –ö–≤–∞–¥—Ä–∞—Ç–Ω—ã–π –º–∞—Å—Å–∏–≤ –∏–∑ –∫–ª–µ—Ç–æ–∫.

    Returns
        bool
            True - —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—É—Ç—å
            False - –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—É—Ç—å.

    '''
    if checkVerticalSides(grid):
        return True
    if checkHorisontalSides(grid):
        return True
    return False


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


def mod_checkSides(grid):
    '''
    –ë–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å 
        –º–µ–∂–¥—É –¥–≤—É–º—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–º–∏ –≥—Ä–∞–Ω—è–º–∏

    –ö—Ä–∞—Ç–∫–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º:
        1. –°–æ–∑–¥–∞–µ—Ç—Å—è –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ —Å–æ —Å—Ç–æ—Ä–æ–Ω–æ–π –Ω–∞ 2 –∫–ª–µ—Ç–∫–∏ –±–æ–ª—å—à–µ
        2. –ó–Ω–∞—á–µ–Ω–∏—è –∏–∑ –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞ –ø—Ä–∏—Å–≤–∞–∏–≤–∞—é—Ç—Å—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–º –∫–ª–µ—Ç–∫–∞–º 
            –º–æ–¥. –º–∞—Å—Å–∏–≤–∞ (–±—É–¥—Ç–æ –≤–µ—Å—å –∏–∑–Ω–∞—á–∞–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ –æ–∫—Ä—É–∂–∏–ª–∏ 
            –Ω–µ–ø—Ä–æ–≤–æ–¥—è—â–∏–º–∏ –∫–ª–µ—Ç–∫–∞–º–∏)
        3. –°–æ–∑–¥–∞—é—Ç—Å—è –ø—Ä–æ–≤–æ–¥—è—â–∏–µ –ø–ª–∞—Å—Ç–∏–Ω—ã —Å–ª–µ–≤–∞-—Å–ø—Ä–∞–≤–∞ –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è, 
            –µ—Å—Ç—å –ª–∏ –ø—É—Ç—å –æ—Ç —Å–µ—Ä–µ–¥–∏–Ω—ã –æ–¥–Ω–æ–π –ø–ª–∞—Å—Ç–∏–Ω—ã –¥–æ —Å–µ—Ä–µ–¥–∏–Ω—ã –¥—Ä—É–≥–æ–π
            –ó–∞—Ç–µ–º –ø–ª–∞—Å—Ç–∏–Ω—ã —É–±–∏—Ä–∞—é—Ç—Å—è 
        4. –°–æ–∑–¥–∞—é—Ç—Å—è –ø—Ä–æ–≤–æ–¥—è—â–∏–µ –ø–ª–∞—Å—Ç–∏–Ω—ã —Å–≤–µ—Ä—Ö—É-—Å–Ω–∏–∑—É –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è, 
            –µ—Å—Ç—å –ª–∏ –ø—É—Ç—å –æ—Ç —Å–µ—Ä–µ–¥–∏–Ω—ã –æ–¥–Ω–æ–π –ø–ª–∞—Å—Ç–∏–Ω—ã –¥–æ —Å–µ—Ä–µ–¥–∏–Ω—ã –¥—Ä—É–≥–æ–π
            –ó–∞—Ç–µ–º –ø–ª–∞—Å—Ç–∏–Ω—ã —É–±–∏—Ä–∞—é—Ç—Å—è

    –≠—Ç–æ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º –±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π, –ø–æ—Ç–æ–º—É —á—Ç–æ —Å–æ–∑–≤–æ–ª—è–µ—Ç —Å–≤—è–∑–∞—Ç—å –≤—Å–µ 
        –ø—Ä–æ–≤–æ–¥—è—â–∏–µ –∫–ª–µ—Ç–∫–∏ —Å –æ–¥–Ω–æ–π –≥—Ä–∞–Ω–∏, —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ, –≤ –æ–¥–Ω—É, –∏ –æ–¥–Ω–∏–º 
        –≤—ã–∑–æ–≤–æ–º —Ñ—É–Ω–∫—Ü–∏–∏ PathExists() –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å 

    Parameters
    ----------
    grid : 2D NxN array of Cells
        –ö–≤–∞–¥—Ä–∞—Ç–Ω—ã–π –º–∞—Å—Å–∏–≤ –∏–∑ –∫–ª–µ—Ç–æ–∫.

    Returns
        bool
            True - —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—É—Ç—å
            False - –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—É—Ç—å.

    '''
    mod_N = N+2

    p1 = (0, round(mod_N/2))
    p2 = (mod_N-1, round(mod_N/2))
    p3 = (round(mod_N/2), 0)
    p4 = (round(mod_N/2), mod_N-1)

    # –°–æ–∑–¥–∞—Ç—å –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å–µ—Ç–∫—É, —à–∏—Ä–∏–Ω–∞ –∏ –¥–ª–∏–Ω–∞ –Ω–∞ 2 –∫—Ä–µ—Ç–∫–∏ –±–æ–ª—å—à–µ
    # –ó–Ω–∞—á–µ–Ω–∏—è –∫–∞–∂–¥–æ–π –∫–ª–µ—Ç–∫–∏ —Ä–∞–≤–Ω—ã –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ 1
    mod_grid = [[Cell((i, j), pass_val=0) for j in range(mod_N)]
                for i in range(mod_N)]

    # –ü–µ—Ä–µ–¥–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ–π —Å–µ—Ç–∫–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π —á–∞—Å—Ç–∏ –º–æ–¥. —Å–µ—Ç–∫–∏
    for i in range(N):
        for j in range(N):
            mod_grid[i+1][j+1].setVal(grid[i][j].getVal())

    # # –°–¥–µ–ª–∞—Ç—å —É–≥–ª—ã –º–æ–¥. —Å–µ—Ç–∫–∏ –Ω–µ–ø—Ä–æ–≤–æ–¥—è—â–∏–º–∏ (–∑–Ω–∞—á–µ–Ω–∏—è = 0)
    mod_grid[0][0].setVal(0)
    mod_grid[mod_N-1][0].setVal(0)
    mod_grid[0][mod_N-1].setVal(0)
    mod_grid[mod_N-1][mod_N-1].setVal(0)

    # –°–æ–∑–¥–∞—Ç—å 2 –ø–ª–∞—Å—Ç–∏–Ω—ã —Å–ª–µ–≤–∞ –∏ —Å–ø—Ä–∞–≤–∞
    for i in range(N):
        mod_grid[0][i+1].setVal(1)
        mod_grid[mod_N-1][i+1].setVal(1)

    # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –µ—Å—Ç—å –ª–∏ –º–µ–∂–¥—É –ø–ª–∞—Å—Ç–∏–Ω–∞–º–∏ –ª–µ–≤–æ-–ø—Ä–∞–≤–æ –ø—É—Ç—å
    if PathExists(mod_grid, p1, p2, mod_N):
        return True

    # –£–±—Ä–∞—Ç—å 2 –ø–ª–∞—Å—Ç–∏–Ω—ã —Å–ª–µ–≤–∞ –∏ —Å–ø—Ä–∞–≤–∞
    for i in range(N):
        mod_grid[0][i+1].setVal(0)
        mod_grid[mod_N-1][i+1].setVal(0)

    # –°–æ–∑–¥–∞—Ç—å 2 –ø–ª–∞—Å—Ç–∏–Ω—ã —Å–≤–µ—Ä—Ö—É –∏ —Å–Ω–∏–∑—É
    for i in range(N):
        mod_grid[i+1][0].setVal(1)
        mod_grid[i+1][mod_N-1].setVal(1)

    # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –µ—Å—Ç—å –ª–∏ –º–µ–∂–¥—É –ø–ª–∞—Å—Ç–∏–Ω–∞–º–∏ –≤–µ—Ä—Ö-–Ω–∏–∑ –ø—É—Ç—å
    if PathExists(mod_grid, p3, p4, mod_N):
        return True
    return False


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


def draw_prob_ro_dependency():
    '''
    –í–∞—Ä—å–∏—Ä—É–µ—Ç ro –≥–ª–æ–±–∞–ª—å–Ω–æ –∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑ 
        –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å –ø–æ –ø—Ä–æ–≤–æ–¥—è—â–∏–º –∫–ª–µ—Ç–∫–∞–º
    –ó–∞–ø–∏—Å—ã–≤–∞–µ—Ç —á–∞—Å—Ç–æ—Ç—É –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –ø—É—Ç–µ–π –∏ –≤—ã–≤–æ–¥–∏—Ç –≥—Ä–∞—Ñ–∏–∫
        –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –æ—Ç ro
    –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –∑–∞–Ω–∏–º–∞–µ—Ç –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ - –¥–µ—Å—è—Ç–∫–∏ –º–∏–Ω—É—Ç
    –ü–æ—ç—Ç–æ–º—É –¥–ª—è –¥–µ–º–æ–Ω—Å—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –≤—ã—Å—Ç–∞–≤–∏—Ç—å 
        —Ä–∞–∑–º–µ—Ä –º–∞—Å—Å–∏–≤–∞ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–≤–µ—Ä–æ–∫ –ø–æ–º–µ–Ω—å—à–µ 
    –ü—Ä–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö —ç—Ç–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∫–∞–∫ 50, 3 —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ 
        –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –æ–∫–æ–ª–æ –º–∏–Ω—É—Ç—ã –∏ –≤—ã–¥–∞—ë—Ç –∫–∞—Ä—Ç–∏–Ω—É, 
        –±–ª–∏–∑–∫—É—é –∫ –∂–µ–ª–∞–µ–º–æ–π

    Returns
        None.
    '''
    global ro

    ro_st, ro_ed, ro_num = 0, 1, 51
    ro_arr = np.linspace(ro_st, ro_ed, ro_num, endpoint=True)

    prob = []
    for ro in ro_arr:
        N_list = []
        for _ in range(number_of_checks):
            cellsList = [[Cell((i, j)) for j in range(N)] for i in range(N)]
            if mod_checkSides(cellsList):
                N_list.append(1)
            else:
                N_list.append(0)

        prob.append(np.mean(N_list))

    plt.plot(ro_arr, prob)
    plt.grid()


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


def drawGrid(grid, tmp_N=None):
    '''
    –§—É–Ω–∫—Ü–∏—è, –æ—Ç—Ä–∏—Å–æ–≤—ã–≤–∞—é—â–∞—è —Å–µ—Ç–∫—É –∏–∑ –∫–ª–µ—Ç–æ–∫

    Parameters
    ----------
    grid : 2D NxN array of Cells
        –ö–≤–∞–¥—Ä–∞—Ç–Ω—ã–π –º–∞—Å—Å–∏–≤ –∏–∑ –∫–ª–µ—Ç–æ–∫.
    tmp_N : int
        –†–∞–∑–º–µ—Ä –º–∞—Å—Å–∏–≤–∞.

    Returns
        None.
    '''
    if tmp_N == None:
        tmp_N = N

    x1 = []
    y1 = []

    for i in range(tmp_N):
        for j in range(tmp_N):
            if grid[i][j].val == 1:
                x1.append(i)
                y1.append(j)

    plt.plot(x1, y1, 'ro')


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


st = time.perf_counter()

N = 50  # –†–∞–∑–º–µ—Ä –º–∞—Å—Å–∏–≤–∞
ro = 0.5
number_of_checks = 10  # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–≤–µ—Ä–æ–∫


# –ö–∞–∫ —Å–æ–∑–¥–∞–µ—Ç—Å—è –¥–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤ —Å –æ–±—ä–µ–∫—Ç–∞–º–∏ Cell
cellsList = [[Cell((i, j)) for j in range(N)] for i in range(N)]

# –ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å —Å–µ—Ç–∫—É –≤ Matplotlib
# drawGrid(cellsList)


draw_prob_ro_dependency()

# Hoshen_Kopelman(cellsList)

# print(f'–ù–æ—Ä–º –ø—Ä–æ–≤–µ—Ä–∫–∞ {checkSides(cellsList)}')
# print(f'–ú–æ–¥ –ø—Ä–æ–≤–µ—Ä–∫–∞ {mod_checkSides(cellsList)}')
# print(f'H –ø—Ä–æ–≤–µ—Ä–∫–∞ {checkHoshen_Kopelman(cellsList)}')

# plt.show()


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------


print(f'Eval took: {time.perf_counter() - st} sec')
